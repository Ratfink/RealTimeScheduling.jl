var documenterSearchIndex = {"docs":
[{"location":"weaklyhard/#Weakly-Hard-Systems","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"","category":"section"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"RealTimeScheduling provides basic support for weakly hard constraints.","category":"page"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"warning: Warning\nSupport for weakly hard systems is still a work in progress, and the API is still very incomplete.  For now, we mainly support the constraints themselves, as well as comparisons between them.","category":"page"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"WeaklyHardConstraint\nMeetAny\nMissAny\nMeetRow\nMissRow","category":"page"},{"location":"weaklyhard/#RealTimeScheduling.WeaklyHardConstraint","page":"Weakly Hard Systems","title":"RealTimeScheduling.WeaklyHardConstraint","text":"Abstract parent type of all weakly hard constraints\n\nThe concrete subtypes of this, and many of the methods defined on them, are due to Bernat, Burns, and Llamosí, \"Weakly Hard Real-Time Systems,\" IEEE Trans. Computers, Vol. 50, No. 4, April 2001.\n\n\n\n\n\n","category":"type"},{"location":"weaklyhard/#RealTimeScheduling.MeetAny","page":"Weakly Hard Systems","title":"RealTimeScheduling.MeetAny","text":"MeetAny{T}(meet::T, window::T)\n\nWeakly hard constraint specifying that a task meets meet deadlines in any window of size window.\n\n\n\n\n\n","category":"type"},{"location":"weaklyhard/#RealTimeScheduling.MissAny","page":"Weakly Hard Systems","title":"RealTimeScheduling.MissAny","text":"MissAny([T=Int, ]miss, window)\n\nConstruct a MeetAny{T} constraint that allows at most miss deadlines to be missed in any window of size window.\n\nWhile constraints of this sort are often expressed as a different type in the literature, they are equivalent to MeetAny, so using a single type simplifies any code using weakly hard constraints.\n\n\n\n\n\n","category":"function"},{"location":"weaklyhard/#RealTimeScheduling.MeetRow","page":"Weakly Hard Systems","title":"RealTimeScheduling.MeetRow","text":"MeetRow{T}(meet::T, window::T)\n\nWeakly hard constraint specifying that a task meets meet deadlines in a row in any window of size window.\n\n\n\n\n\n","category":"type"},{"location":"weaklyhard/#RealTimeScheduling.MissRow","page":"Weakly Hard Systems","title":"RealTimeScheduling.MissRow","text":"MissRow{T}(miss::T)\n\nWeakly hard constraint specifying that a task misses at most miss deadlines in a row.\n\n\n\n\n\n","category":"type"},{"location":"weaklyhard/#Sampling-from-Weakly-Hard-Constraints","page":"Weakly Hard Systems","title":"Sampling from Weakly Hard Constraints","text":"","category":"section"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"A weakly hard constraint can be viewed as a sample space of bit strings, with 0 representing a deadline miss, and 1 representing a deadline hit.  A finite length must be provided to generate such a string.  For now, we only support uniform sampling from MissRow constraints.","category":"page"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"Unfortunately, the requirement of specifying a string length precludes the easiest use of the Random.rand API.  However, the precomputation required is non-negligible, so it would be a good idea to first create a sampler anyway.","category":"page"},{"location":"weaklyhard/","page":"Weakly Hard Systems","title":"Weakly Hard Systems","text":"SamplerUniformMissRow","category":"page"},{"location":"weaklyhard/#RealTimeScheduling.SamplerUniformMissRow","page":"Weakly Hard Systems","title":"RealTimeScheduling.SamplerUniformMissRow","text":"SamplerUniformMissRow(constraint::MissRow, H::Int64)\n\nPre-compute data for uniformly sampling BitVector objects from a MissRow constraint.  The sampled vectors will have length H.\n\nThe algorithm used is due to Bernardi, Olivier, and Omer Giménez, \"A linear algorithm for the random sampling from regular languages.\" Algorithmica 62.1 (2012): 130-145.\n\nExamples\n\njulia> sp = SamplerUniformMissRow(MissRow(3), 10);\n\njulia> rand(sp)\n10-element BitVector:\n1\n1\n0\n1\n1\n0\n1\n0\n0\n1\n\n\n\n\n\n","category":"type"},{"location":"tasks/#Tasks","page":"Tasks","title":"Tasks","text":"","category":"section"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"RealTimeScheduling provides several different representations of real-time tasks.  These include periodic tasks with implicit or explicit deadlines.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"AbstractRealTimeTask\nPeriodicTask\nPeriodicImplicitTask","category":"page"},{"location":"tasks/#RealTimeScheduling.AbstractRealTimeTask","page":"Tasks","title":"RealTimeScheduling.AbstractRealTimeTask","text":"Abstract parent type of all real-time task types\n\n\n\n\n\n","category":"type"},{"location":"tasks/#RealTimeScheduling.PeriodicTask","page":"Tasks","title":"RealTimeScheduling.PeriodicTask","text":"PeriodicTask{S}(period::S, deadline::S, cost::S)\n\nConcrete type for periodic real-time tasks.\n\n\n\n\n\n","category":"type"},{"location":"tasks/#RealTimeScheduling.PeriodicImplicitTask","page":"Tasks","title":"RealTimeScheduling.PeriodicImplicitTask","text":"PeriodicImplicitTask{S}(period::S, cost::S)\n\nConcrete type for periodic real-time tasks with implicit deadline.\n\n\n\n\n\n","category":"type"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"The task types can be converted to one another automatically, and PeriodicImplicitTask objects can also be promoted to PeriodicTask when required (e.g. when putting both types of task into a single TaskSystem).","category":"page"},{"location":"tasks/#Task-Attributes","page":"Tasks","title":"Task Attributes","text":"","category":"section"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"Of course, methods are provided to get a task's period, relative deadline, and execution cost.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"period\ndeadline\ncost","category":"page"},{"location":"tasks/#RealTimeScheduling.period","page":"Tasks","title":"RealTimeScheduling.period","text":"period(τ)\n\nReturn the period of the real-time task τ.\n\n\n\n\n\n","category":"function"},{"location":"tasks/#RealTimeScheduling.deadline","page":"Tasks","title":"RealTimeScheduling.deadline","text":"deadline(τ)\n\nReturn the deadline of the real-time task τ.\n\n\n\n\n\n","category":"function"},{"location":"tasks/#RealTimeScheduling.cost","page":"Tasks","title":"RealTimeScheduling.cost","text":"cost(τ)\n\nReturn the cost, or worst-case execution time, of the real-time task τ.\n\n\n\n\n\n","category":"function"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"Utilization and density can be computed easily as well.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"utilization(::AbstractRealTimeTask)\ndensity(::AbstractRealTimeTask)","category":"page"},{"location":"tasks/#RealTimeScheduling.utilization-Tuple{AbstractRealTimeTask}","page":"Tasks","title":"RealTimeScheduling.utilization","text":"utilization(τ::AbstractRealTimeTask)\n\nCompute the utilization of real-time task τ, cost/period.\n\nSee also density.\n\n\n\n\n\n","category":"method"},{"location":"tasks/#RealTimeScheduling.density-Tuple{AbstractRealTimeTask}","page":"Tasks","title":"RealTimeScheduling.density","text":"density(τ::AbstractRealTimeTask)\n\nCompute the density of real-time task τ, cost/min(period, deadline).\n\nSee also utilization.\n\n\n\n\n\n","category":"method"},{"location":"tasks/#Testing-Properties-of-Tasks","page":"Tasks","title":"Testing Properties of Tasks","text":"","category":"section"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"Sometimes it's useful to know how the deadline of a task relates to its period. RealTimeScheduling provides two functions for this.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"implicit_deadline(::AbstractRealTimeTask)\nconstrained_deadline(::AbstractRealTimeTask)","category":"page"},{"location":"tasks/#RealTimeScheduling.implicit_deadline-Tuple{AbstractRealTimeTask}","page":"Tasks","title":"RealTimeScheduling.implicit_deadline","text":"implicit_deadline(τ::AbstractRealTimeTask)\n\nTest whether the real-time task τ has relative deadline equal to period.\n\n\n\n\n\n","category":"method"},{"location":"tasks/#RealTimeScheduling.constrained_deadline-Tuple{AbstractRealTimeTask}","page":"Tasks","title":"RealTimeScheduling.constrained_deadline","text":"constrained_deadline(τ::AbstractRealTimeTask)\n\nTest whether the real-time task τ has relative deadline at most period.\n\n\n\n\n\n","category":"method"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"Additionally, it's often important to know if a task's cost exceeds its period.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"feasible(::AbstractRealTimeTask)","category":"page"},{"location":"tasks/#RealTimeScheduling.feasible-Tuple{AbstractRealTimeTask}","page":"Tasks","title":"RealTimeScheduling.feasible","text":"feasible(τ::AbstractRealTimeTask)\n\nTest whether the real-time task τ is feasible, i.e. its density is at most 1.\n\n\n\n\n\n","category":"method"},{"location":"tasks/#Time-Demand-Analysis","page":"Tasks","title":"Time-Demand Analysis","text":"","category":"section"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"Many schedulability tests make use of time-demand analysis (TDA).  To support this, the common demand bound function (DBF) and request bound function (RBF) are implemented.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"demand_bound(::AbstractRealTimeTask, ::Real)\nrequest_bound(::AbstractRealTimeTask, ::Real)","category":"page"},{"location":"tasks/#RealTimeScheduling.demand_bound-Tuple{AbstractRealTimeTask, Real}","page":"Tasks","title":"RealTimeScheduling.demand_bound","text":"demand_bound(τ::AbstractRealTimeTask, t)\n\nCompute Baruah's demand bound function (DBF) for the task τ.\n\n\n\n\n\n","category":"method"},{"location":"tasks/#RealTimeScheduling.request_bound-Tuple{AbstractRealTimeTask, Real}","page":"Tasks","title":"RealTimeScheduling.request_bound","text":"request_bound(τ::AbstractRealTimeTask, t)\n\nCompute the request bound function (RBF) for the task τ.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/#Task-Systems","page":"Task Systems","title":"Task Systems","text":"","category":"section"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"For interesting schedulability problems, a set of tasks needs to be contained within a task system.  RealTimeSystems provides such a type, which is a fairly thin wrapper around a standard Vector.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"AbstractRealTimeTaskSystem\nTaskSystem","category":"page"},{"location":"tasksystems/#RealTimeScheduling.AbstractRealTimeTaskSystem","page":"Task Systems","title":"RealTimeScheduling.AbstractRealTimeTaskSystem","text":"Abstract parent type of all real-time task system types\n\n\n\n\n\n","category":"type"},{"location":"tasksystems/#RealTimeScheduling.TaskSystem","page":"Task Systems","title":"RealTimeScheduling.TaskSystem","text":"TaskSystem{T} <: AbstractRealTimeTaskSystem\n\nA concrete real-time task system, holding a Vector of tasks of type T.\n\n\n\n\n\n","category":"type"},{"location":"tasksystems/#Testing-Properties-of-Task-Systems","page":"Task Systems","title":"Testing Properties of Task Systems","text":"","category":"section"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"As with individual tasks, it can be useful to check if all tasks in a task system are implicit or constrained deadline.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"implicit_deadline(::AbstractRealTimeTaskSystem)\nconstrained_deadline(::AbstractRealTimeTaskSystem)","category":"page"},{"location":"tasksystems/#RealTimeScheduling.implicit_deadline-Tuple{AbstractRealTimeTaskSystem}","page":"Task Systems","title":"RealTimeScheduling.implicit_deadline","text":"implicit_deadline(T::AbstractRealTimeTaskSystem)\n\nTest whether all real-time tasks in T are implicit deadline.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/#RealTimeScheduling.constrained_deadline-Tuple{AbstractRealTimeTaskSystem}","page":"Task Systems","title":"RealTimeScheduling.constrained_deadline","text":"constrained_deadline(T::AbstractRealTimeTaskSystem)\n\nTest whether all real-time tasks in T are constrained deadline.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"It's just as easy to compute the utilization or density of a task system.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"utilization(::AbstractRealTimeTaskSystem)\ndensity(::AbstractRealTimeTaskSystem)","category":"page"},{"location":"tasksystems/#RealTimeScheduling.utilization-Tuple{AbstractRealTimeTaskSystem}","page":"Task Systems","title":"RealTimeScheduling.utilization","text":"utilization(T::AbstractRealTimeTaskSystem)\n\nReturn the sum utilization of all tasks in T.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/#RealTimeScheduling.density-Tuple{AbstractRealTimeTaskSystem}","page":"Task Systems","title":"RealTimeScheduling.density","text":"density(T::AbstractRealTimeTaskSystem)\n\nReturn the sum density of all tasks in T.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"Additionally, it's often a sensible check to verify that a task system is feasible before doing other tests on it.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"feasible(::AbstractRealTimeTaskSystem)","category":"page"},{"location":"tasksystems/#RealTimeScheduling.feasible-Tuple{AbstractRealTimeTaskSystem}","page":"Task Systems","title":"RealTimeScheduling.feasible","text":"feasible(T::AbstractRealTimeTaskSystem)\n\nTest whether the real-time task system T is feasible, i.e. its density is at most 1.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/#Task-Priority","page":"Task Systems","title":"Task Priority","text":"","category":"section"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"For fixed-priority (FP) scheduling, RealTimeSystems uses an implicit model of task priority, whereby the index of a task in a given TaskSystem is its priority.  Lower indices are considered higher priority, as is usually the case in the literature.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"We provide two functions to sort a TaskSystem in order of increasing period and relative deadline.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"rate_monotonic!\ndeadline_monotonic!","category":"page"},{"location":"tasksystems/#RealTimeScheduling.rate_monotonic!","page":"Task Systems","title":"RealTimeScheduling.rate_monotonic!","text":"rate_monotonic!(T::AbstractRealTimeTaskSystem)\n\nSort the task system T from lowest to highest period.\n\n\n\n\n\n","category":"function"},{"location":"tasksystems/#RealTimeScheduling.deadline_monotonic!","page":"Task Systems","title":"RealTimeScheduling.deadline_monotonic!","text":"deadline_monotonic!(T::AbstractRealTimeTaskSystem)\n\nSort the task system T from lowest to highest period.\n\n\n\n\n\n","category":"function"},{"location":"tasksystems/#Time-Demand-Analysis","page":"Task Systems","title":"Time-Demand Analysis","text":"","category":"section"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"Many schedulability tests make use of time-demand analysis (TDA).  To support this, the common demand bound function (DBF) and request bound function (RBF) are implemented for task systems.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"demand_bound(::AbstractRealTimeTaskSystem, ::Real)\nrequest_bound(::AbstractRealTimeTaskSystem, ::Real)","category":"page"},{"location":"tasksystems/#RealTimeScheduling.demand_bound-Tuple{AbstractRealTimeTaskSystem, Real}","page":"Task Systems","title":"RealTimeScheduling.demand_bound","text":"demand_bound(T::AbstractRealTimeTaskSystem, t)\n\nCompute Baruah's demand bound function (DBF) for task system T.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/#RealTimeScheduling.request_bound-Tuple{AbstractRealTimeTaskSystem, Real}","page":"Task Systems","title":"RealTimeScheduling.request_bound","text":"request_bound(T::AbstractRealTimeTaskSystem, t)\n\nCompute the request bound function (RBF) for task system T.\n\n\n\n\n\n","category":"method"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"Using the RBF, the package provides an implementation of TDA for uniprocessor fixed-priority task systems.","category":"page"},{"location":"tasksystems/","page":"Task Systems","title":"Task Systems","text":"schedulable_fixed_priority","category":"page"},{"location":"tasksystems/#RealTimeScheduling.schedulable_fixed_priority","page":"Task Systems","title":"RealTimeScheduling.schedulable_fixed_priority","text":"schedulable_fixed_priority(T)\n\nCheck if the AbstractRealTimeTaskSystem T is schedulable by a fixed priority scheduler, with tasks prioritized by index (low to high).\n\nExamples\n\nLehoczky's counterexample to use of traditional TDA when deadlines exceed periods:\n\njulia> ts = TaskSystem([PeriodicTask(70, 70, 26), PeriodicTask(100, 118, 62)]);\n\njulia> schedulable_fixed_priority(ts)\ntrue\n\nShortening the deadline of task 2 makes the system unschedulable:\n\njulia> ts[2] = PeriodicTask(100, 116, 62);\n\njulia> schedulable_fixed_priority(ts)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#RealTimeScheduling.jl","page":"RealTimeScheduling.jl","title":"RealTimeScheduling.jl","text":"","category":"section"},{"location":"","page":"RealTimeScheduling.jl","title":"RealTimeScheduling.jl","text":"Real-time systems modeling and schedulability analysis","category":"page"},{"location":"","page":"RealTimeScheduling.jl","title":"RealTimeScheduling.jl","text":"This package aims to provide useful tools for writing schedulability studies with Julia.  The functionality is currently quite minimal, as the package is in early stages of development, but more features will be added in the future. It is inspired by SchedCAT by Björn Brandenburg, but is not a direct port since Julia isn't Python. 😉","category":"page"}]
}
